/ CPP program to illustrate 
// Implementation of erase() function 
#include <iostream> 
#include <vector> 
using namespace std; 
  
int main() 
{ 
    vector<int> myvector{ 1, 2, 3, 4, 5 }; 
    vector<int>::iterator it1, it2; 
  
    it1 = myvector.begin(); 
    it2 = myvector.end(); 
    it2--; 
    it2--; 
  
    myvector.erase(it1, it2); 
  
    // Printing the Vector 
    for (auto it = myvector.begin(); it != myvector.end(); ++it) 
        cout << ' ' << *it; 
    return 0; 
} 

Program error signals

Signals in computers are a way of communication between the process and the OS. When a running program undergoes some serious error then the OS sends a signal to the process and the process further may not execute. Some processes may have a signal handler which does some important tasks before the process leaves the CPU.

Signal and interrupt are basically same but a small distinction exists i.e interrupts are generated by the processor and handled by the kernel but signals are generated by the kernel and handled by the process. Error signals generally causes termination of the program and a core dump file is created named core, which stores the state of the process at the moment of termination. This file can be investigated using debugger to know the cause of program termination.

Error signals:
    SIGFPE –
    This error signal denotes some arithmetic error that occurred like division by zero, floating point error. If a program stores integer data in a location which is then used as a floating-point operation, this causes an “invalid operation” exception as the processor cannot recognize the data as a floating-point value. But this signal does not specify the type of floating point error.
    SIGILL –
    This signal denotes illegal instruction. When a garbage instruction or instruction which a program has no privilege to execute, is executed then this signal is generated. C does not produce illegal instruction so there is no chance of facing such error signal, as the probable cause may be that the object file may be corrupted. This signal is also generated when stack overflow occurs.
    SIGSEGV –
    The signal is generated when process tries to access memory location not allocated to it, like de-referencing a wild pointer which leads to “segmentation fault”. The signal is only generated when a program goes far from its memory space so that it can be detected by the memory protection mechanism.
    The name is an abbreviation for “segmentation violation”.
    SIGBUS –
    The name is an abbreviation for “Bus error”. This signal is also produced when an invalid memory is accessed. It may seem to be same like SIGSEGV but in SIGSEGV, the memory location referenced is valid but in case of SIGBUS, memory referenced does not exist i.e de-referencing a memory location out of memory space.
    SIGABRT –
    If an error itself is detected by the program then this signal is generated using call to abort(). This signal is also used by standard library to report an internal error. assert() function in c++ also uses abort() to generate this signal.
    SIGSYS –
    This signal is sent to process when an invalid argument is passed to a system call.
    SIGTRAP –
    This signal is send to process when an exception is occurred. This is requested by the debugger to get informed. For example, if a variable changes its value then this will trigger it.

// CPP program to illustrate 
// difference b/w std::remove 
// and std::vector::erase algorithm 
#include <bits/stdc++.h> 

int main() 
{ 
	std::vector<int> vec{ 10, 20, 30, 30, 20, 10, 10, 20 }; 
	std::vector<int> ve{ 10, 20, 30, 30, 20, 10, 10, 20 }; 

	// Print original vector 
	std::cout << "Original vector :"; 
	for (int i = 0; i < vec.size(); i++) 
		std::cout << " " << vec[i]; 
	std::cout << "\n"; 

	// Iterator that store the position of last element 
	std::vector<int>::iterator pend; 

	// std :: remove function call 
	pend = std::remove(vec.begin(), vec.end(), 20); 

	// Print the vector after std :: remove 
	std::cout << "Range contains:"; 
	for (std::vector<int>::iterator p = vec.begin(); p != pend; ++p) 
		std::cout << ' ' << *p; std::cout << '\n'; 

			// Print original vector 
			std::cout << "Original Vector :"; 
	for (int i = 0; i < ve.size(); i++) 
		std::cout << " " << ve[i]; 
	std::cout << "\n"; 

	// std :: vector :: erase function call 
	// erase the first 3 elements of vector vector 
	ve.erase(ve.begin(), ve.begin() + 3); 

	// Print the vector 
	std::cout << "Vector contains :"; 
	for (int i = 0; i < ve.size(); i++) 
		std::cout << " " << ve[i]; 
	std::cout << "\n"; 

	return 0; 
} 
Original vector : 10 20 30 30 20 10 10 20
Range contains: 10 30 30 10 10

Original Vector : 10 20 30 30 20 10 10 20
Vector contains : 30 20 10 10 20




Comparison to qsort and sort()
1. Implementation details:
As the name suggests, qsort function uses QuickSort algorithm to sort the given array, although the C standard does not require it to implement quicksort.

C++ sort function uses introsort which is a hybrid algorithm. Different implementations use different algorithms. The GNU Standard C++ library, for example, uses a 3-part hybrid sorting algorithm: introsort is performed first (introsort itself being a hybrid of quicksort and heap sort) followed by an insertion sort on the result.

2. Complexity :
The C standard doesn’t talk about its complexity of qsort. The new C++11 standard requires that the complexity of sort to be O(Nlog(N)) in the worst case. Previous versions of C++ such as C++03 allow possible worst case scenario of O(N^2). Only average complexity was required to be O(N log N).

3. Running time:
STL’s sort ran faster than C’s qsort, because C++’s templates generate optimized code for a particular data type and a particular comparison function.

STL’s sort runs 20% to 50% faster than the hand-coded quicksort and 250% to 1000% faster than the C qsort library function. C might be the fastest language but qsort is very slow.

When we tried to sort one million integers on C++14, Time taken by C qsort() was 0.247883 sec and time taken by C++ sort() was only 0.086125 sec
